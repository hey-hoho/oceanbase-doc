# 通过 DBLink 访问远端数据库中的数据

您可以通过 DBLink 访问远端数据库的对象，对象包括表、视图、同义词、序列等。

## 前提条件

已创建 DBLink，创建 DBLink 的详细操作，参见 [创建 DBLink](../1000.manage-dblink-of-oracle-mode/100.create-a-dblink-of-oracle-mode.md)。

## 访问远端数据库中表的数据

您可以使用 `SELECT... FROM 表名@DBLink 名` 语法来访问远端数据库中表的数据，SQL 语句如下：

```sql
SELECT select_expr_list 
      FROM table_name@dblink_name 
      WHERE where_conditions;
 
select_expr_list:
    table_name.*
    | table_alias_name.*
    | expr [[AS] column_alias_name]
```

语句使用说明：

* `select_expr_list`：指定待查询的表达式或列名，不同的列之间用英文逗号（,）隔开，星号（\*）表示所有列。

  * `table_name.*`：指定从指定的表、视图中选择所有的列。

  * `table_alias_name.*`：指定表、视图的别名。

  * `expr [[AS] column_alias_name]`：指定查询列或表达式的别名，`AS` 为可选。

* `table_name@dblink_name`：指定待查询的远端数据库的表，多个数据库之间用英文逗号（,）隔开。

* `where_conditions`：指定筛选条件，查询结果中仅包含满足条件的数据，为可选项。

更多 DBLink 相关的查询语句，参见 [SIMPLE SELECT](../../../500.sql-reference/100.sql-syntax/300.common-tenant-of-oracle-mode/900.sql-statement-of-oracle-mode/200.dml-of-oracle-mode/500.select-of-oracle-mode/100.simple-select-of-oracle-mode.md)。

通过名为 `my_link` 的 DBLink 查询远端数据库中表 `tbl1` 的数据的示例如下：

```sql
obclient> SELECT * FROM tbl1@my_link;
```

## 访问远端数据库中的序列

OceanBase 数据库从 V4.2.1 版本开始，支持通过 DBLink 访问远端数据库中的序列值。

示例如下：

1. 在本地数据库中，创建到远端 OceanBase 数据库 Oracle 租户的 DBLink `my_link` 和一个数据库表 `tbl1`。

   * 创建 DBLink `my_link`

      ```sql
      obclient> CREATE DATABASE LINK my_link CONNECT TO ob_user@oracle IDENTIFIED BY ****** HOST 'xx.xx.xx.xx:2881';
      ```

   * 创建表 `tbl1`

      ```sql
      obclient> CREATE TABLE tbl1 (C1 int,C2 int);
      ```

2. 在远端的 OceanBase 数据库中，创建序列 `seq`。

   ```sql
   obclient> CREATE SEQUENCE seq START WITH 10000 INCREMENT BY 1 CACHE 50 NOCYCLE;
   ```

   创建成功后，确认序列的下一个值是 `10000`。

   ```sql
   obclient> SELECT seq.nextval FROM DUAL;
   ```

   结果如下：

   ```shell
   +---------+
   | NEXTVAL |
   +---------+
   |   10000 |
   +---------+
   1 row in set
   ```

   更多序列相关的操作，请参见 [管理序列](../600.management-sequence-of-oracle-mode.md)。

3. 在本地数据库中，通过 DBLink 查看远端序列的下一个值和当前值。

   * 查询下一个值

     ```sql
     obclient> SELECT seq.nextval@my_link FROM DUAL;
     ```

     查询结果如下：

     ```shell
     +---------+
     | NEXTVAL |
     +---------+
     |   10001 |
     +---------+
     1 row in set
     ```

   * 查询当前值

     ```sql
     obclient> SELECT seq.currval@my_link FROM DUAL;
     ```

     查询结果如下：

     ```shell
     +---------+
     | CURRVAL |
     +---------+
     |   10001 |
     +---------+
     1 row in set
     ```

4. 将远端序列的值通过 DBLink 插入到本地数据库的表中。

   ```sql
   obclient> INSERT INTO tbl1(C1,C2) VALUES (1,seq.nextval@my_link);
   ```

   插入成功后，查询表中的数据：

   ```sql
   obclient> SELECT * FROM tbl1;
   ```
   
   
   结果如下：

   ```shell
   +------+-------+
   | C1   | C2    |
   +------+-------+
   |    1 | 10002 |
   +------+-------+
   1 row in set
   ```

需要注意，在某些特殊场景下，OceanBase 数据库为了提升远端数据库对象查询的性能，可能会导致系统无法获取到远端序列的 `CURRVAL` 最新的值。例如，以下查询语句中，OceanBase 数据库会将整个 `SELECT` 部分的语句交给远端执行，而本地仅负责拉取数据及插入数据，待语句执行成功后，再通过 `SELECT seq.currval#my_link FROM DUAL;` 语句查询 `CURRVAL` 值时，可能无法获取到最新的值。

```sql
INSERT INTO local_tbl1 SELECT remote_tbl1.NAME, seq.nextval@my_link FROM remote_tbl1@my_link;
```

## 调用远端数据库中的存储过程

OceanBase 数据库从 V4.2.1 版本开始，支持通过 DBLink 调用远端数据库中的存储过程。

通过 DBLink 调用远端数据库中的存储过程前，需要注意以下事项：

* 使用 DBLink 功能调用远端 Oracle 数据库上的存储过程时，如果远端数据库版本为 Oracle-19C 及以上版本，则需要在本地 OceanBase 数据库中安装并配置 OCI-12.2；如果远端数据库版本为 Oracle-12C 及以下版本，则需要在本地 OceanBase 数据库中安装并配置 OCI-11.2。

  安装和配置 OCI-12.2 的详细操作，请参见 [安装和配置 OCI-12.2](600.install-and-configure-the-oci-122.md)。

  安装和配置 OCI-11.2 的详细操作，请参见 [安装和配置 OCI-11.2](610.install-and-configure-the-oci-112.md)

* 当前仅支持通过 DBLink 调用远端数据库中的独立存储过程和包存储过程，暂不支持 UDF（User-Defined functions）和包函数的远程调用。

* 调用独立存储过程时，支持以下基础类型的出入参：

  * VARCHAR2、VARCHAR、CHAR 等字符串类型

  * NUMBER、INT、INTEGER、FLOAT、DOUBLE 等数值类型

  * DATA 类型

  * TIMESTAMP 类型

* 调用包存储过程时，不支持包类型为构造函数，支持包类型为以下复合数据类型的出入参：

  * [记录类型](../../../500.sql-reference/300.pl-reference/300.pl-oracle/400.collections-and-records-oracle/800.record-oracle.md)

     同时，还要求记录类型的元素类型必须是以下基础类型：

    * VARCHAR2、VARCHAR、CHAR 等字符串类型

    * NUMBER、INT、INTEGER、FLOAT、DOUBLE 等数值类型

    * DATA 类型

    * TIMESTAMP 类型

   但是，需要注意，对于远端 Oracle 数据库为 oracle-12c 及以下版本的场景，包类型必须是出现在包中 Routine 参数位置的类型。如果仅在包中定义，未在包中任何 Routine 参数中使用，则不支持调用。

  * [嵌套表](../../../500.sql-reference/300.pl-reference/300.pl-oracle/400.collections-and-records-oracle/500.nested-table-oracle.md)、[关联数组](../../../500.sql-reference/300.pl-reference/300.pl-oracle/400.collections-and-records-oracle/300.associative-array-oracle.md)

    同时，要求嵌套表和关联数组的元素类型必须是记录类型和以下基础类型：

    * VARCHAR2、VARCHAR、CHAR 等字符串类型

    * NUMBER、INT、INTEGER、FLOAT、DOUBLE 等数值类型

    * DATA 类型

    * TIMESTAMP 类型
  
* 支持调用远端 Oracle 数据库内部的存储过程或包的同义词，同时也支持调用本地数据库中创建的远端对象的同义词。

下面以几个简单的示例进行说明。假设本地 OceanBase 数据库中创建了到远端 OceanBase 数据库的 DBLink `my_link`。

```sql
obclient> CREATE DATABASE LINK my_link CONNECT TO ob_user@oracle IDENTIFIED BY ****** HOST 'xx.xx.xx.xx:2881';
```

* 调用一个简单的独立存储过程

  1. 准备数据环境。

     远端 OceanBase 数据库 Oracle 租户中存在着一张客户信息表 `customer_info`:

     ```sql
     obclient> CREATE TABLE customer_info
            (id NUMBER,
            name VARCHAR2(20));
     ```

     并向表中插入如下所示数据：

     ```sql
     obclient> INSERT INTO customer_info VALUES(1,'ZHAO'),(2,'LI');
     ```

     执行 `SELECT * FROM customer_info` 语句查询表中的数据，结果如下：

     ```shell
     +------+------+
     | ID   | NAME |
     +------+------+
     |    1 | ZHAO |
     |    2 | LI   |
     +------+------+
     2 rows in set
     ```

     同时远端数据库中还创建了一个存储过程，该存储过程用于接收一个 `customer_id` 参数，并返回该客户的 ID。

     ```sql
     obclient> CREATE OR REPLACE PROCEDURE get_customer_id (
       customer_id IN NUMBER
     )
     IS
     BEGIN
         DBMS_OUTPUT.PUT_LINE('Customer ID is: ' || customer_id);
     END;
     /
     ```
 
  2. 在本地数据库中调用存储过程。

     设置服务器输出：

     ```sql
     bclient> SET SERVEROUTPUT ON;
     ```
  
     再执行调用语句：

     ```sql
     obclient> CALL get_customer_id@my_link(1);
     ```

     输出结果如下：

     ```shell
     Customer ID is: 1
     ```

  但是，当前暂不支持通过以下方式调用该存储过程：

  ```sql
  SELECT get_customer_id@my_link(1) FROM DUAL;
  ```

  除此之外，如果您为远端 Oracle 数据库上的存储过程 `get_customer_id` 创建了以下同义词：

  * 在远端 Oracle 数据库上创建同义词 `syn_remote_customer_id`

    ```sql
    CREATE OR REPLACE SYNONYM syn_remote_customer_id FOR get_customer_id;
    ```

  * 在本地 OceanBase 数据库上通过 DBLink 创建存储过程 `get_customer_id` 的同义词 `syn_local_customer_id`

    ```sql
    CREATE OR REPLACE SYNONYM syn_local_customer_id FOR get_customer_id@my_link;
    ```

  您都可以通过 DBLink 直接调用这些同义词，调用语句如下：

  * 调用远端 Oracle 数据库上的同义词

    ```sql
    CALL syn_remote_customer_id@my_link(1)；
    ```

  * 调用本地 OceanBase 数据库上的同义词

    ```sql
    CALL syn_local_customer_id(1)；
    ```

* 调用一个包含出入参的存储过程

  如下所示，假设远端数据库中存在着一张员工表:

  ```sql
  obclient> CREATE TABLE employees
        (name VARCHAR2(20),
        id NUMBER);
  ```

  还有一个存储过程，该存储过程用于接收一个 `employee_id` 参数，并返回对应的员工姓名。如果找不到对应的员工，则返回 `Employee not found` 的信息，如果发生其他异常，则返回 `Error occurred`。

  ```sql
  obclient> CREATE OR REPLACE PROCEDURE get_employee_name (
      employee_id IN NUMBER,
      employee_name OUT VARCHAR2(20)
  )
  IS
  BEGIN
      SELECT name INTO employee_name
      FROM employees
      WHERE id = employee_id;
  EXCEPTION
      WHEN NO_DATA_FOUND THEN
          employee_name := 'Employee not found';
      WHEN OTHERS THEN
          employee_name := 'Error occurred';
  END;
  /
  ```

  入参 `employee_id` 和出参 `employee_name` 的数据类型均符合要求，您可以在本地数据库中，执行 `SET SERVEROUTPUT ON;` 设置服务器输出后，再通过以下语句调用存储过程。

  ```sql
  DECLARE
    employee_name VARCHAR2(20);
  BEGIN
    get_employee_name@orcl_dblink(1, employee_name);
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || employee_name);
  end;
  /
  ```

  输出结果如下：

   ```shell
   Employee Name: Employee not found
   ```

* 调用一个包类型为复合数据类型的出入参的包存储过程

  如下所示，在远端数据库中，存在一个程序包 `pkg1`，该包包含了多种复合数据类型，包括记录和嵌套表，同时还包含一个名为 `pro1` 的存储过程。

  ```sql
  CREATE OR REPLACE PACKAGE pkg1 AS
      TYPE ty1 IS RECORD(c1 varchar2(10), c2 int);
      TYPE ty2 IS TABLE OF varchar2(10);
      TYPE ty3 IS TABLE OF ty1;
      TYPE ty4 IS TABLE OF varchar2(10) INDEX BY PLS_INTEGER;
      TYPE ty5 IS TABLE OF ty1 INDEX BY PLS_INTEGER;
      TYPE ty6 IS TABLE OF varchar2(10);
      PROCEDURE pro1(param1 ty1, param2 ty2, param3 ty3 , param4 ty4, param5 ty5);
  END;
  /
  ```
  
  包 `pkg1` 对应的包主体如下：

  ```sql
  CREATE OR REPLACE PACKAGE BODY pkg1 AS
      PROCEDURE pro1(param1 ty1, param2 ty2, param3 ty3, param4 ty4, param5 ty5) IS
      BEGIN
          DBMS_OUTPUT.PUT_LINE('Parameter 1: ' || param1.c1 || ', ' || param1.c2);
          DBMS_OUTPUT.PUT_LINE('Parameter 2: ' || param2(1) || ', ' || param2(2));
          FOR i IN param3.FIRST .. param3.LAST LOOP
              DBMS_OUTPUT.PUT_LINE('Parameter 3(' || i || '): ' || v3(i).c1 || ', ' || v3(i).c2);
          END LOOP;
      END pro1;
  END pkg1;
  /
  ```

  您可以通过以下语句调用包存储过程：---这里调用语句怎么执行都不成功？？？

  ```sql
  DECLARE
    param1 pkg1.ty1@my_link;
    param2 pkg1.ty2@my_link;
    param3 pkg1.ty3@my_link;
    param4 pkg1.ty4@my_link;
    param5 pkg1.ty5@my_link;
  BEGIN
    pkg1.pro1@my_link(param1, param2, param3, param4, param5);
  END;
  /
  ```

  对于远端数据库为 oracle-12c 及以下版本的场景，由于 `ty6` 没有出现在包 `pkg1` 内部 Routine 的参数列表位置，故通过以下语句调用包存储过程就会报错：

  ```sql
  DECLARE
    v1 pkg1.ty6@orcl_dblink;
  BEGIN
    null;
  END;
  /
  ```

  有关包的更多使用及说明，请参见 [创建程序包](../../../500.sql-reference/300.pl-reference/300.pl-oracle/900.package-oracle/200.create-a-package-oracle.md)。

## 相关文档

更多 DBLink 相关的操作，参见以下信息：

* [创建 DBLink](../1000.manage-dblink-of-oracle-mode/100.create-a-dblink-of-oracle-mode.md)

* [查看 DBLink](../1000.manage-dblink-of-oracle-mode/200.view-a-dblink-of-oracle-mode.md)

* [通过 DBLink 修改远端数据库的数据](../1000.manage-dblink-of-oracle-mode/400.update-data-in-remote-database-by-a-dblink-of-oracle-mode.md)

* [删除 DBLink](../1000.manage-dblink-of-oracle-mode/500.delete-a-dblink-of-oracle-mode.md)
